# -*- coding: utf-8 -*-
"""cross_puzzle.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hH2LRT3wPnHuzSdzM9JUVQiml8VPI6mz
"""

def parse_puzzle():
    H = int(input().strip())
    board = []
    for _ in range(H):
        board.append(list(input().strip()))

    def find_connected_groups(board):
        H = len(board)
        W = 5
        visited = [[False] * W for _ in range(H)]
        groups = []
        def dfs(r, c, num, group):
            if (r < 0 or r >= H or c < 0 or c >= W or
                visited[r][c] or board[r][c] != num or board[r][c] == '.'):
                return

            visited[r][c] = True
            group.append((r, c))

            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                dfs(r + dr, c + dc, num, group)

        for r in range(H):
            for c in range(W):
                if not visited[r][c] and board[r][c] != '.':
                    group = []
                    dfs(r, c, board[r][c], group)
                    if len(group) > 1:
                        groups.append(group)

        return groups

    def eliminate_blocks(board, groups):

        new_board = [row[:] for row in board]
        for group in groups:
            for r, c in group:
                new_board[r][c] = '.'
        return new_board

    def apply_gravity(board):
        H = len(board)
        W = 5
        new_board = [['.' for _ in range(W)] for _ in range(H)]

        for c in range(W):
            blocks = []
            for r in range(H):
                if board[r][c] != '.':
                    blocks.append(board[r][c])

            for i, block in enumerate(blocks):
                new_board[H - len(blocks) + i][c] = block

        return new_board

    while True:
        groups = find_connected_groups(board)
        if not groups:
            break

        board = eliminate_blocks(board, groups)
        board = apply_gravity(board)

    for row in board:
        print(''.join(row))

parse_puzzle()

